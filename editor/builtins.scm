(define (map func lst)
  (if (null? lst)
      nil
      (cons (func (car lst))
            (map func (cdr lst))
      )
  )
)

; EECS 390 removals
; (define (filter func lst)
;   (cond ((null? lst) nil)
;         ((func (car lst))
;          (cons (car lst)
;                (filter func (cdr lst))
;          ))
;         (else (filter func (cdr lst)))
;   )
; )
;
; (define (reduce func lst)
;   (cond ((null? lst) nil)
;         ((null? (cdr lst)) (car lst))
;         (else
;          (reduce func
;                  (cons (func (car lst) (car (cdr lst)))
;                        (cdr (cdr lst))
;                  )
;          ))
;   )
; )

(define (cdr-stream stream)
  (force (cdr stream)))

; EECS 390 additions

; syntax
(define-macro (let* vars body-first . body-rest)
    (if (null? vars)
        `(begin ,body-first ,@body-rest)
        `(let ((,(caar vars) ,(cadar vars)))
              (let* ,(cdr vars) ,body-first ,@body-rest)
        )
    )
)

(define-macro (<case-impl> key-evaluated first-branch . rest-branches)
    (cond ((or (eq? (car first-branch) 'else)
               (memv key-evaluated (car first-branch))
           )
           `(begin ,@(cdr first-branch)))
          ((not (null? rest-branches)) `(<case-impl> ,key-evaluated ,@rest-branches))
    )
)
(define-macro (case key first-branch . rest-branches)
    `(<case-impl> ,(eval key) ,first-branch ,@rest-branches)
)

; numbers
; (define real? number?)
;
; (define exact? integer?)
; (define (inexact? value)
;   (and (number? value) (not (exact? value)))
; )
;
; (define (positive? value)
;   (> value 0)
; )
; (define (negative? value)
;   (< value 0)
; )
;
; (define (max x1 . xs)
;   (<minmax-impl> > x1 xs)
; )
; (define (min x1 . xs)
;   (<minmax-impl> < x1 xs)
; )
; (define (<minmax-impl> compare so-far rest)
;   (cond ((null? rest) so-far)
;         ((compare (car rest) so-far)
;          (<minmax-impl> compare (car rest) (cdr rest)))
;         (else (<minmax-impl> compare so-far (cdr rest)))
;   )
; )
;
; (define (gcd . values)
;   (if (null? values)
;       0
;       (let ((x (abs (car values)))
;             (y (apply gcd (cdr values))))
;         (<gcd-impl> (max x y) (min x y))
;       )
;   )
; )
; (define (<gcd-impl> x y)
;   (if (= y 0)
;       x
;       (gcd y (remainder x y))
;   )
; )
; (define (lcm . values)
;   (if (null? values)
;       1
;       (let ((x (abs (car values)))
;             (y (apply lcm (cdr values))))
;         (/ (* x y) (gcd x y))
;       )
;   )
; )
;
; (define ceiling ceil)
; (define truncate trunc)
; (define (round value)
;     (let ((below (floor value))
;           (above (ceiling value)))
;       (cond ((= above below) above)
;             ((< (- value below) (- above value)) below)
;             ((> (- value below) (- above value)) above)
;             ((even? below) below)
;             (else above)
;       )
;     )
; )

; pairs and lists
; (define (caar x) (car (car x)))
; (define (cadr x) (car (cdr x)))
; (define (cdar x) (cdr (car x)))
; (define (cddr x) (cdr (cdr x)))
; (define (caaar x) (car (car (car x))))
; (define (caadr x) (car (car (cdr x))))
; (define (cadar x) (car (cdr (car x))))
; (define (caddr x) (car (cdr (cdr x))))
; (define (cdaar x) (cdr (car (car x))))
; (define (cdadr x) (cdr (car (cdr x))))
; (define (cddar x) (cdr (cdr (car x))))
; (define (cdddr x) (cdr (cdr (cdr x))))
; (define (caaaar x) (car (car (car (car x)))))
; (define (caaadr x) (car (car (car (cdr x)))))
; (define (caadar x) (car (car (cdr (car x)))))
; (define (caaddr x) (car (car (cdr (cdr x)))))
; (define (cadaar x) (car (cdr (car (car x)))))
; (define (cadadr x) (car (cdr (car (cdr x)))))
; (define (caddar x) (car (cdr (cdr (car x)))))
; (define (cadddr x) (car (cdr (cdr (cdr x)))))
; (define (cdaaar x) (cdr (car (car (car x)))))
; (define (cdaadr x) (cdr (car (car (cdr x)))))
; (define (cdadar x) (cdr (car (cdr (car x)))))
; (define (cdaddr x) (cdr (car (cdr (cdr x)))))
; (define (cddaar x) (cdr (cdr (car (car x)))))
; (define (cddadr x) (cdr (cdr (car (cdr x)))))
; (define (cdddar x) (cdr (cdr (cdr (car x)))))
; (define (cddddr x) (cdr (cdr (cdr (cdr x)))))

; (define (<member-impl> compare obj items)
;     (cond ((null? items) #f)
;           ((compare obj (car items)) (car items))
;           (else (<member-impl> compare obj (cdr items)))
;     )
; )
; (define (member obj items) (<member-impl> equal? obj items))
; (define (memv obj items) (<member-impl> eqv? obj items))
; (define (memq obj items) (<member-impl> eq? obj items))
;
; (define (<assoc-impl> compare obj alist)
;     (<member-impl> (lambda (a b) (compare a (car b))) obj alist)
; )
; (define (assoc obj items) (<assoc-impl> equal? obj items))
; (define (assv obj items) (<assoc-impl> eqv? obj items))
; (define (assq obj items) (<assoc-impl> eq? obj items))
